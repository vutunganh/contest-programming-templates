\documentclass{article}
\usepackage[shorthands=off, czech]{babel}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\hypersetup{
  colorlinks=true,
  linkcolor=blue,
  linktoc=all
}
\usepackage{listings}
\usepackage{inconsolata}

% nastavuje code blocks
\lstset{
  basicstyle=\footnotesize,
  language=C++,
  numbers=none
}

\title{Knihovna týmu My z Kačerova}
\author{Matyáš Křišťan, Jan Uhlík, Vu Tung Anh}

\begin{document}

\tableofcontents

\section{Algoritmy}
\subsection{Grafové algoritmy}

\subsubsection{Topsort}
O(n + m)
\lstinputlisting[firstline = 21, lastline = 41]{../Matyas/Templates/algorithms/graph.cpp}

\subsubsection{Floyd Warshall}
O(n**3)
\lstinputlisting[firstline = 44, lastline =61]{../Matyas/Templates/algorithms/graph.cpp}

\subsubsection{Maximální párování}
\lstinputlisting{../Tung/hopcroft-karp.cpp}

\subsubsection{Dijkstra}
\lstinputlisting[firstline = 24, lastline = 54]{../Tung/dijkstra.cpp}

\subsection{Stromové algoritmy}
\subsubsection{LCA}
O(n * log(n))
\lstinputlisting[firstline = 66, lastline = 98]{../Matyas/Templates/algorithms/graph.cpp}

\subsubsection{Nejdelší cesta ve stromě}
O(těžko říct, s každým dalším query se zlepšuje)
\lstinputlisting[firstline = 100, lastline = 129]{../Matyas/Templates/algorithms/graph.cpp}

\subsubsection{Střed stromu}
O(n)
\lstinputlisting[firstline = 132, lastline = 167]{../Matyas/Templates/algorithms/graph.cpp}


\subsection{Stringové algoritmy}
\subsubsection{Longest common substring}
O(n * m)
Jenom délka.
\lstinputlisting[firstline = 11, lastline = 22]{../Matyas/Templates/algorithms/string.cpp}

\subsubsection{Longest common subsequence}
O(n * m)
Jenom délka.
\lstinputlisting[firstline = 25, lastline = 38]{../Matyas/Templates/algorithms/string.cpp}

\subsection{Mergesort s inverzemi}
O(n * log(n)) asi
\lstinputlisting[firstline = 17, lastline = 44]{../Matyas/Templates/algorithms/mergesort.cpp}

\subsection{Binární vyhledávání}
\lstinputlisting[firstline = 7]{../Matyas/Templates/algorithms/binary-search.cpp}

\newpage

\section{Datové struktury}

\subsection{Big Integer}
\lstinputlisting[firstline = 9]{../Matyas/Templates/math/big-int.cpp}

\subsection{Fenwick}
JEŠTĚ JEDNOU ZDŮRAZNÍM, ŽE SE NEPOUŽÍVÁ T[0]
\lstinputlisting{../Tung/fenwick.cpp}

\subsection{Union Find}
\lstinputlisting[firstline = 2]{../Matyas/Templates/data-structures/union-find.cpp}

\newpage

\section{Matematika}

\subsection{Struktury}
\subsubsection{Matice}
\lstinputlisting[firstline = 13, lastline = 43]{../Matyas/Templates/math/common.cpp}

\subsection{GCD}
\lstinputlisting[firstline = 46, lastline = 60]{../Matyas/Templates/math/common.cpp}

\subsection{Kombinačni číslo}
\lstinputlisting[firstline = 63, lastline = 77]{../Matyas/Templates/math/common.cpp}

\subsection{Modularní inverze}
\lstinputlisting[firstline = 80, lastline = 114]{../Matyas/Templates/math/common.cpp}

\subsection{Kombinační číslo modulené(?)}
\lstinputlisting[firstline = 117, lastline = 130]{../Matyas/Templates/math/common.cpp}

\subsection{Eratosthenova síta}
\begin{lstlisting}
  vector<int> getPrimes(int upTo) {
    vector<int> result = {2, 3, 5};
    for (int i = 6; i <= upTo; ++i) {
      bool isPrime = true;
      for (int j = 0; 
           j < result.size() && result[j] * result[j] <= i; 
           ++ j) {
        if (i % result[j] == 0) {
          isPrime = false;
        }
      }
      if (isPrime)
        result.push_back(i);
      }
    return result;
  }

  vector<int> erasothenes(int upTo) {
    vector<bool> sieve(upTo + 1, false);
    for (int i = 2; i <= upTo; ++i) {
      if (!sieve[i]) {
        for (int j = 2*i; j <= upTo; j += i) {
          sieve[j] = true;
        }
      }
    }

    vector<int> result;
    for (int i = 2; i <= upTo; ++i) {
      if (!sieve[i])
        result.push_back(i);
      }
    return result;
  }
\end{lstlisting}

\subsection{Faktorizace}
\begin{lstlisting}
  vector<pair<int, int>> 
  factors(int n, const vector<int> & primes) {
    vector<pair<int, int>> result;
    for (int i = 0; i < primes.size() && primes[i] <= n; ++i) {
      int c = 0;
      while (n % primes[i] == 0) {
        c ++;
        n /= primes[i];
      }
      if (c != 0) {
        result.push_back({primes[i], c});
      }
    }
    return result;
  }
\end{lstlisting}

\subsection{Počet dělitelů (potřeba faktorizace výše!)}
\begin{lstlisting}
  int divisorsCount(const vector<pair<int, int>> &facts) {
    int d = 1;
    for (int i = 0; i < facts.size(); ++i) {
      d *= (facts[i].second + 1);
    }
    return d;
  }
\end{lstlisting}

\subsection{Počet čtvercových dělitelů}
\begin{lstlisting}
  int squareDivisors(vector<pair<int, int>> facts) {
    bool confirm = false;
    // set to false if not counting proper divisorsCount
    bool isEvenPerfectSquare = true;

    for (int i = 0; i < facts.size(); ++i) {
      if (facts[i].second % 2 != 0) isEvenPerfectSquare = false;
      if (facts[i].first == 2 && facts[i].second >= 2) {
        confirm = true;
        facts[i].second -= 2;
      }
      facts[i].second /= 2;
    }

    int subtract = (confirm && isEvenPerfectSquare) ? 1 : 0;

    if (confirm)
      return divisorsCount(facts) - subtract;
    else
      return 0;
    }
\end{lstlisting}

\subsection{Rychlé umocňování čísel}
\begin{lstlisting}
  int ipow(int base, int exp) {
    int result = 1;
      while (exp)
      {
        if (exp & 1) {
            result *= base;
            // modulit tady
          }
        exp >>= 1;
        base *= base;
        // modulit tady
      }

      return result;
    }
\end{lstlisting}

\subsection{Rychlé umocňování matic}
\begin{lstlisting}
  Matrix ipow(Matrix base, ll exp) {
    Matrix result(base.rows, true);
    while (exp)
    {
      if (exp & 1)
          result = result * base;
      exp >>= 1;
      base = base * base;
    }

    return result;
  }
\end{lstlisting}

\subsection{Rozšířené Eratosthenovo síto}
Faktorizace v O(log(n))
\begin{lstlisting}
  vector<int> erasothenesExt(int upTo) {
    vector<bool> v(upTo + 1, false);
    vector<int> sp(upTo + 1, 0);
    for (int i = 2; i <= upTo; ++i) {
      if (!v[i]) {
        for (int j = 2*i; j <= upTo; j += i) {
          if (!v[j]) {
            v[j] = true;
            sp[j] = i;
          }
        }
        sp[i] = i;
      }
    }
    sp[1] = 1;
    return sp;
  }
\end{lstlisting}

// rychla faktorizace v O(log(n)) za pomoci rozsireneho sita
\subsection{Rychlá faktorizace}
Potreba rozsirene Eratosthenovo sito vyse
\begin{lstlisting}
  vector<P> fastFactors(int n, vector<int> & sieve) {
    int c;
    vector<P> divs;
    divs.push_back({sieve[n], 1});
    n /= sieve[n];
    while (n != 1) {
      c = sieve[n];
      if (divs.back().first != c) {
        divs.push_back({c, 1});
      } else {
        divs.back().second ++;
      }
      n = n/sieve[n];
    }
    return divs;
  }
\end{lstlisting}

\subsection{Fast divisors}
At je to cokoliv

\begin{lstlisting}
  // pomocna funkce pro fastDivisors
  void getDivs(vector<int> & res, 
               vector<P> & divs,
               int t, int i) {
    if (i >= divs.size()) {
      res.push_back(t);
      return;
    }
    int n = t;
    for (int j = 0; j <= divs[i].second; ++j) {
      getDivs(res, divs, n, i + 1);
      n *= divs[i].first;
    }
  }

  // ziska delitele v asymptoticky optimalnim case
  vector<int> fastDivisors(int n, vector<int> sieve) {
    vector<P> divs = fastFactors(n, sieve);
    vector<int> exp(divs.size(), 0);
    vector<int> result;

    getDivs(result, divs, 1, 0);
    return result;
  }
\end{lstlisting}
\end{document}

\subsection{Minimal subarray sum}
Nejkratsi usek pole roven nejakemu k.

\begin{lstlisting}
  int minSubarraySum(vector<int> ar, int k) {
    if (k == 0) return 0;
    int minLen = INT_MAX;
    int start = 0, end = 0;
    int curSum = ar[0];
    while (end != ar.size() - 1 || start != ar.size() - 1) {
      if (curSum == k) minLen = min(minLen, end - start + 1);

      if (curSum >= k && start < end) {
        curSum -= ar[start];
        start++;
      } else {
        if (end < ar.size() - 1) {
          end++;
          curSum += ar[end];
        } else {
          break;
        }
      }
    }
    if (curSum == k) minLen = min(minLen, end - start + 1);
    return minLen;
  }
\end{lstlisting}

\subsection{Odčítání v modulu}
Proprietary (x - y) \% k
\lstinputlisting[]
\begin{lstlisting}
inline ll modsub( ll x, ll y, ll k )
{
  return ( x % k - y % k + k ) % k;
}
\end{lstlisting}
