\documentclass[10pt, a4paper]{article}

\usepackage[czech]{babel}

\usepackage[unicode]{hyperref}
\hypersetup{
  colorlinks=true,
  linkcolor=black,
  linktoc=all
}

\usepackage{geometry}
\geometry{
 a4paper,
 top=25mm,
 bottom=25mm,
 left=25mm,
 right=25mm
}

\usepackage{listings}
\lstset{
  breakatwhitespace=true,
  breaklines=true,
  frame=tb,
  language=C++,
  numbers=left,
  tabsize=2
}


\title{Knihovna týmu Zavalleni}

\begin{document}

\section{Algoritmy}
\subsection{Grafové algoritmy}

\subsubsection{Bellman-ford}
\lstinputlisting{../algorithms/graph/bellman-ford.cpp}

\subsubsection{Dijkstra}
\lstinputlisting{../algorithms/graph/dijkstra.cpp}

\subsubsection{Dinicův algoritmus}
Maximální tok v $O(V^2 \cdot E)$.
\lstinputlisting{../algorithms/graph/dinic.cpp}

\subsubsection{Floyd Warshall}
$O(n^3)$
\lstinputlisting{../algorithms/graph/floyd-warshall.cpp}

\subsubsection{Globální minimální hranový řez}
Stoer-Wagner, $O(V^3)$
\lstinputlisting{../algorithms/graph/stoer-wagner.cpp}

\subsubsection{Kruskal}
\lstinputlisting{../algorithms/graph/kruskal.cpp}

\subsubsection{Maximální párování}
Něco jako $O(\sqrt{V}E)$.
\lstinputlisting{../algorithms/graph/hopcroft-karp.cpp}

\subsubsection{Topsort}
Asi přepracovat, moc Javovský. $O(n + m)$
\lstinputlisting{../algorithms/graph/topsort.cpp}

\subsection{Stromové algoritmy}

\subsubsection{Dominace stromu}
$O(n)$, resp takové DFS.
\lstinputlisting{../algorithms/graph/tree-dominating-set.cpp}

\subsubsection{Nejdelší cesta ve stromě}
$O(\hbox{těžko říct, s každým dalším query se zlepšuje})$
\lstinputlisting{../algorithms/graph/tree-diameter.cpp}

\subsubsection{Offline tree LCA}
$O(n\log(n))$
\lstinputlisting{../algorithms/graph/offline-tree-lca.cpp}

\subsubsection{Střed stromu}
$O(n)$
\lstinputlisting{../algorithms/graph/tree-center.cpp}


\subsection{Stringové algoritmy}

\subsubsection{Levenshtein}
\lstinputlisting{../algorithms/string/levenshtein.cpp}

\subsubsection{Longest common continuous substring}
Jenom délka, $O(n \cdot m)$.
\lstinputlisting{../algorithms/string/longest-common-continuous-substring.cpp}

\subsubsection{Longest common substring}
Jenom délka, $O(n \cdot m)$.
\lstinputlisting{../algorithms/string/longest-common-substring.cpp}

\subsubsection{Suffix tree + LCP + použití na Longest common subsequence}
O(n)
\lstinputlisting[firstline = 1, lastline = 103]{../Matyas/ACM2/7/longest-common-substring/template.cpp}

\subsection{Binární vyhledávání}
\lstinputlisting{../algorithms/binary-search.cpp}

\subsection{Mergesort s inverzemi}
$O(n\log(n))$
\lstinputlisting{../algorithms/mergesort.cpp}

\subsection{Nejkratší úsek pole se součtem roven k}
Pouze pro kladné prvky pole
\lstinputlisting{../algorithms/min-subarray-sum.cpp}

\newpage

\section{Datové struktury}

\subsection{Big Integer}
\lstinputlisting{../data-structures/big-int.cpp}

\subsection{Bitová trie}
\lstinputlisting{../data-structures/bit-trie.cpp}

\subsection{Block cut tree}
\lstinputlisting{../data-structures/blockcut-tree.cpp}

\subsection{Fenwick}
JEŠTĚ JEDNOU ZDŮRAZNÍM, ŽE SE NEPOUŽÍVÁ T[0]\\
Chcete-li použít Fenwicka jako \uv{segmenťák} (tedy update je \texttt{add(l,d)+add(r+1,-d)}), pak query stačí jako \texttt{pref\_sum(i)} a není třeba odečítat $i-1$.
\lstinputlisting{../data-structures/fenwick.cpp}

\subsection{Jak na rychlé mapy}
\begin{lstlisting}
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;
cc_hash_table<ll,ll> N;
gp_hash_table<ll,ll> M; // o ~10% pomalejsi read/write, ale 3-6x rychlejsi insert/delete/clear
\end{lstlisting}

\subsection{Maximový Fenwick}
\lstinputlisting{../data-structures/max-fenwick.cpp}

\subsection{Union Find}
\lstinputlisting{../data-structures/union-find.cpp}

\newpage

\section{Matematika}

\subsection{Dělitelé}
\lstinputlisting{../math/divisors.cpp}

\subsubsection{Rychlejší za pomoci síta}
\lstinputlisting{../math/fast-divisors.cpp}

\subsection{Eratosthenova síta}
To první je nějaký úplný basic v $O(n^{\frac{3}{2}})$. To druhé je poněkud lepší s časem $O(n\log(\log n))$. To třetí je rozšířené o to, že si pro každé číslo pamatuje nejmenšího prvočíselného dělitelé, tzn. dá se tím dělat rychlý rozklad na prvočísla.
\lstinputlisting{../math/sieves.cpp}

\subsection{Faktorizace}
To první je basic faktorizace v čase $O(\sqrt n)$, které vrátí vektor dvojic (dělitel, mocnina). To druhé využívá síto, vrátí vektor prvočíselných dělitelů.
\lstinputlisting{../math/factorization.cpp}

\subsection{GCD}
\begin{lstlisting}
__gcd(a,b);
\end{lstlisting}

\subsection{Jak správně generovat náhodná čísla?}
\begin{lstlisting}
  random_device r;
  mt19937 e(r()); // nebo mt19937_64 pro 64 bitova cisla
  uniform_int_distribution<int> give_random(0,100000) // pravy kraj inclusive (kdybychom chteli generovat intmax)
  give_random(e); // tohle vraci random cislo
\end{lstlisting}

\subsection{Kombinačni číslo}
\lstinputlisting{../math/combination.cpp}

\subsection{Modularní inverze}
Pouze pro prvočíselná modula. Vychází z malé Fermatovy věty.
\lstinputlisting{../math/modinv.cpp}

\subsection{Odečítání v modulu}
\lstinputlisting{../math/modsub.cpp}

\subsection{Počet čtvercových dělitelů}
\lstinputlisting{../math/square-divisors.cpp}

\subsection{Prefixový xor aritmetické řady}
\lstinputlisting{../math/prefix-xor-arithmetic-sequence.cpp}

\subsection{Rozšířený Euklidův algoritmus}
\lstinputlisting{../math/eea.cpp}

\subsection{Ternární vyhledávání}
$O(\log(n))$
\lstinputlisting{../math/ternary-search.cpp}

\subsection{Umocňování}
\lstinputlisting{../math/fast-exponent.cpp}

\subsection{Struktury}

\subsubsection{Čísla v modulu}
\lstinputlisting{../math/mod-num.cpp}

\subsubsection{Matice}
\lstinputlisting{../math/matrix.cpp}

\newpage

\section{Misc}

\subsection{Parser}
\lstinputlisting{../misc/parser.cpp}

\newpage

\section{Geometrie}
\lstinputlisting{../geometry/template.cpp}

\newpage

\section{Konfiguráky}
\subsection{Vim}
\lstinputlisting{../vimrc}
\subsection{Bash}
\lstinputlisting{../bashrc}
\subsection{Template}
\lstinputlisting{../template/template.cpp}

\end{document}

