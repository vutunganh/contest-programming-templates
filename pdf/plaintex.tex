\input opmac
\chyph

\hyperlinks{\Blue}{\Green} % odkazy z obsahu

\def\newpage{\vfil \break} % makro na novou stránku
\def\linebreak{\hfil \break} % makro na nový řádek
\overfullrule=0pt % už žádné černé čtverečky na konci řádků
\def\tthook{\ttline=-2} % nečíslovat řádky kódu

\tit Knihovna týmu Zavalleni

\maketoc

\chap Algoritmy

\sec Grafové algoritmy 

\secc Bellman-ford 

\verbinput (-) ../algorithms/graph/bellman-ford.cpp

\secc Dijkstra 

\verbinput (-) ../algorithms/graph/dijkstra.cpp

\secc Dinicův algoritmus 

Maximální tok v $O(V^2 \cdot E)$.
\verbinput (-) ../algorithms/graph/dinic.cpp

\secc Floyd Warshall 

$O(n^3)$
\verbinput (-) ../algorithms/graph/floyd-warshall.cpp

\secc Globální minimální hranový řez 

Stoer-Wagner, $O(V^3)$
\verbinput (-) ../algorithms/graph/stoer-wagner.cpp

\secc Kruskal 

\verbinput (-) ../algorithms/graph/kruskal.cpp

\secc Maximální párování 

Něco jako $O(\sqrt{V}E)$.
\verbinput (-) ../algorithms/graph/hopcroft-karp.cpp

\secc Topsort 

Asi přepracovat, moc Javovský. $O(n + m)$
\verbinput (-) ../algorithms/graph/topsort.cpp

\sec Stromové algoritmy 

\secc Dominace stromu 

$O(n)$, resp takové DFS.
\verbinput (-) ../algorithms/graph/tree-dominating-set.cpp

\secc Nejdelší cesta ve stromě 

$O(\hbox{těžko říct, s každým dalším query se zlepšuje})$
\verbinput (-) ../algorithms/graph/tree-diameter.cpp

\secc Offline tree LCA 

$O(n\log(n))$
\verbinput (-) ../algorithms/graph/offline-tree-lca.cpp

\secc Střed stromu 

$O(n)$
\verbinput (-) ../algorithms/graph/tree-center.cpp

\sec Stringové algoritmy

\secc Levenshtein 

\verbinput (-) ../algorithms/string/levenshtein.cpp

\secc Longest common continuous substring 

Jenom délka, $O(n \cdot m)$.
\verbinput (-) ../algorithms/string/longest-common-continuous-substring.cpp

\secc Longest common substring 

Jenom délka, $O(n \cdot m)$.
\verbinput (-) ../algorithms/string/longest-common-substring.cpp

\secc Suffix tree + LCP + použití na Longest common subsequence 

O(n)
\verbinput (1-103) ../Matyas/ACM2/7/longest-common-substring/template.cpp

\sec Binární vyhledávání 

\verbinput (-) ../algorithms/binary-search.cpp

\sec Mergesort s inverzemi 

$O(n\log(n))$
\verbinput (-) ../algorithms/mergesort.cpp

\sec Nejkratší úsek pole se součtem roven k 

Pouze pro kladné prvky pole
\verbinput (-) ../algorithms/min-subarray-sum.cpp

\newpage

\chap Datové struktury

\sec Big Integer 

\verbinput (-) ../data-structures/big-int.cpp

\sec Bitová trie 

\verbinput (-) ../data-structures/bit-trie.cpp

\sec Block cut tree 

\verbinput (-) ../data-structures/blockcut-tree.cpp

\sec Fenwick

{\bf JEŠTĚ JEDNOU ZDŮRAZNÍM, ŽE SE NEPOUŽÍVÁ {\tt T[0]}}\linebreak
Chcete-li použít Fenwicka jako \uv{segmenťák} (tedy update je {\tt add(l,d)+add(r+1,-d)}), pak query stačí jako {\tt pref\_sum(i)} a není třeba odečítat $i-1$.
\verbinput (-) ../data-structures/fenwick.cpp

\sec Jak na rychlé mapy 

\begtt
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;
cc_hash_table<ll,ll> N;
gp_hash_table<ll,ll> M; // o ~10% pomalejsi read/write, ale 3-6x rychlejsi insert/delete/clear
\endtt

\sec Maximový Fenwick 

\verbinput (-) ../data-structures/max-fenwick.cpp

\sec Treap

Datová struktura, která umí hledat $k$-tý prvek a zeptat se, kolikátý je nějaký prvek.
Všechny operace amortizovaně $O(\log(n))$.
{\bf Pozor}, neumí to duplicitní prvky, v tom případě se to musí ohnout páry, kde {\tt first} je skutečný prvek a {\tt second} je nějaký hash.
Query se na {\tt cnt} (= počet {\bf menších}) se pak volají na {\tt ($n$, $\infty$)}, pokud počítáme včetně $n$ jinak {\tt ($n$, $-\infty$)} pokud nechceme včetně $n$.

\verbinput (-) ../data-structures/treap.cpp

\sec Union Find 

\verbinput (-) ../data-structures/union-find.cpp

\newpage

\chap Matematika

\sec Dělitelé 

Ve výsledku budou i $1$ a $n$.
\verbinput (-) ../math/divisors.cpp

\secc Rychlejší za pomoci síta 

\verbinput (-) ../math/fast-divisors.cpp

\sec Eratosthenova síta 

To první je nějaký úplný basic v $O(n^{3 \over 2})$. To druhé je poněkud lepší s časem $O(n\log(\log n))$. To třetí je rozšířené o to, že si pro každé číslo pamatuje nejmenšího prvočíselného dělitelé, tzn. dá se tím dělat rychlý rozklad na prvočísla.
\verbinput (-) ../math/sieves.cpp

\sec Faktorizace 

To první je basic faktorizace v čase $O(\sqrt n)$, které vrátí vektor dvojic (dělitel, mocnina). Ta další využívají síta nebo musí znát prvočísla.
\verbinput (-) ../math/factorization.cpp

\sec GCD 

\begtt
__gcd(a,b);
\endtt

\sec Jak správně generovat náhodná čísla? 

\begtt
  random_device r;
  mt19937 e(r()); // nebo mt19937_64 pro 64 bitova cisla
  uniform_int_distribution<int> give_random(0,100000) // pravy kraj inclusive (kdybychom chteli generovat intmax)
  give_random(e); // tohle vraci random cislo
\endtt

\sec Kombinačni číslo 

\verbinput (-) ../math/combination.cpp

\sec Modularní inverze 

Pouze pro prvočíselná modula. Vychází z malé Fermatovy věty.
\verbinput (-) ../math/modinv.cpp

\sec Odečítání v modulu 

\verbinput (-) ../math/modsub.cpp

\sec Počet čtvercových dělitelů 

\verbinput (-) ../math/square-divisors.cpp

\sec Prefixový xor aritmetické řady 

\verbinput (-) ../math/prefix-xor-arithmetic-sequence.cpp

\sec Rozšířený Euklidův algoritmus 

\verbinput (-) ../math/eea.cpp

\sec Ternární vyhledávání 

$O(\log(n))$
\verbinput (-) ../math/ternary-search.cpp

\sec Umocňování 

\verbinput (-) ../math/fast-exponent.cpp

\sec Struktury 


\secc Čísla v modulu 

\verbinput (-) ../math/mod-num.cpp

\secc Matice 

\verbinput (-) ../math/matrix.cpp

\newpage

\chap Misc

\sec Parser 

\verbinput (-) ../misc/parser.cpp

\newpage

\chap Geometrie

\verbinput (-) ../geometry/template.cpp

\newpage

\chap Konfiguráky

\sec Vim 

\verbinput (-) ../vimrc

\sec Bash 

\verbinput (-) ../bashrc

\sec Template 

\verbinput (-) ../template/template.cpp

\bye
